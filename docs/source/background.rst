Η γλώσσα Pazcal και ο μεταγλωτιστής της
========================================

1. Εισαγωγή
------------

Η γλώσσα Pazcal είναι μια απλή γλώσσα προστακτικού προγραμματισμού — είναι 
αυτή που διδάσκεται στο πρώτο εξάμηνο της ΣΗΜΜΥ. Βασίζεται σε ένα γνήσιο
υποσύνολο της ISO C99 (ή της ISO C++11), με αρκετές απλοποιήσεις και μερικά
macros που κατά σύμβαση γράφονται με κεφαλαία γράμματα για να ξεχωρίζουν και
που εδώ εμφανίζονται ως ενσωματωμένα στη γλώσσα. Βασικά χαρακτηριστικά της
γλώσσας είναι:

* η σύνταξη εντολών και εκφράσεων παρόμοια με αυτή της C
* συναρτήσεις με τους κανόνες εμβέλειας της C.
* Βασικοί τύποι δεδομένων για ακέραιους και πραγματικούς αριθμούς, λογικές τιμέ
  και χαρακτήρες.
* Πίνακες με γνωστό ή άγνωστο μέγεθος.
* Βιβλιοθήκη συναρτήσεων

Ως γλώσσα υλοποίησης επιλέχθηκε η OCaml λόγω των εργαλείων ocamllex και
ocamlyacc. Επιπλέον, η εκρφραστικότητα του συναρτησιακού προγραμματισμού φάνηκε
ιδαίτερα χρήσιμη σε όλη την διάρκεια ανάπτυξης. Λόγω της γνώσης από προηγούμενα
μαθήματα της assembly 8086, ως περιβάλλον εκτέλεσης επιλέχθηκε το συστημα DOS,
μέσω του προσομοιωτή DOSBOX.

Παρακάτω, περιγράφουμε τις σχεδιαστικές επιλογές που έγιναν για κάθε τμήμα του
μεταγλωτιστή.

2. Λεκτικός αναλυτής
---------------------

Το πρώτο στάδιο ανάπτυξη του μεταγλωτιστή περιελάμβανε τη δημιουργία του
λεκτικού αναλυτή. Ο λεκτικός αναλυτής είναι εκείνο το κομμάτι του μεταγλωτιστή
που δέχεται σαν είσοδο πηγαίο κώδικα PaZcal και επιστρέφει τα σύμβολα της
γλώσσας που αναγνωρίστηκαν.

Για τη δημιουργία του λεκτικού αναλυτή χρησιμοποιήσαμε το εργαλείο ocamllex της
ocaml. Το εργαλείο αυτό με βάση το αρχείο :download:`Lexer.mll
<../../Lexer.mll>` στο οποίο ορίζονται οι λεκτικές μονάδες της γλώσσας, παράγει
τον OCaml κώδικα του λεκτικού αναλυτή. Το αρχείο αυτό περιέχει τόσο τις
δεσμευμένες λέξεις της γλώσσας όπως ``if``, ``true``, ``and`` κλπ. καθώς,
κανονικές εκφράσεις οι οποίες ορίζουν συμβολοσειρές, αριθμητικές σταθερές κλπ
καθώς και οδηγίες προς το επόμενο στάδιο, όπως το ``end of file``.

Ο λεκτικός αυτός αναλυτής περιλαμβάνει μια συνάρτηση για κάθε λεκτική μονάδα
που ορίζεται στο προηγούμενο αρχείο, η οποία εκτελείται όταν βρεθεί η
συγκεκριμένη λεκτική μονάδα στην είσοδο. Στην περίπτωση ανάγνωσης κάποιου
άγνωστου χαρακτήρα (χαρακτήρα για τον οποίο δεν προδιαγράφεται συγκεκριμένη
λειτουργία) η λεκτική ανάλυση σταματάει και επιστρέφεται μήνυμα λάθους στο
χρήστη.

Ο λεκτικός αναλυτής απομονώνει τις λεκτικές μονάδες που είναι η είσοδος στο
επόμενο στάδιο του μεταγλωτιστή, τον συντακτικό αναλυτή.

3. Συνταντικός αναλυτής
------------------------

Ο συναντικτικός αναλυτής είναι εκείνο το κομμάτι του μεταγλωτιστή που συνδιάζει
τις λεκτικές μονάδες που αναγνωρίζει ο λεκτικός αναλυτής με βάση τη γραμματική
της γλώσσας PaZcal.

Για τη δημιουργία του συντακτικού αναλυτή χρησιμοποιήθηκε το εργαλείο ocamlyacc
της OCaml. Σε αντίστοιχη λογική με το Lexer.mll το ocamlyacc δέχεται σαν είσοδο
το αρχείο :download:`Parser.mly <../../Parser.mly>` και παράγει τον κώδικα του
συντακτικού αναλυτή. Το αρχείο αυτό είναι δομημένο σε 3 τμήματα. Το πρώτο τμήμα
περιέχει κώδικα OCaml βοηθητικών συναρτήσεων, το δεύτερο περιέχει τις λεκτικές
μονάδες που περιμένει από το λεκτικό αναλυτή ο Parser και το τρίτο περιέχει τους
κανόνες τις γραμματικής που δημιουργούνται με βάση τις λεκτικές μονάδες. Μόλις
ένας κανόνας γίνει `reduce` τότε εκτελείται το action που ορίζεται στις αγκύλες
διπλα από τον συγκεκριμένο κανόνα. Το action αυτό περιλαμβάνει τον κώδικα για
την σημασιολογική ανάλυση και την παραγωγή του ενδιάμεσου κώδικα.

Το αρχείο αυτό δημιουργήθηκε με βάση την πλήρη :download:`γραμματική της PaZcal
<pazcal2014.pdf>` τροποποιώντας τη ανάλογα με τους περιορισμούς που
θέτει το ocamlyacc.

Η έξοδος του ocamlyacc είναι το αρχείο ``Parser.ml`` που περιέχει τον κώδικα του
συνακτικού αναλυτή.

4. Σημασιολογική ανάλυση
-------------------------

Ακόμα και αν ένα πρόγραμμα είναι συνακτικά ορθό, δηλαδή οι λεκτικές μονάδες που
το αποτελούν είναι τοποθετημένες σε σειρά σύμφωνη με τη γραμματική της γλώσσας,
είναι πιθανό να περιέχει σημασιολογικά λάθη.

Ο κώδικας του σημασιολογικού αναλυτή είναι σπασμένος σε συναρτήσεις ελέγχου οι
οποίες εφαρμόζονται στον Parser πριν την παραγωγή του ενδιάμεσου κώδικα. Στη
περίπτωση σημασιολογικού λάθους παράγεται το αντίστοιχο μήνυμα σφάλματος που
ενημερώνει το χρήστη για το λάθος το και το σημείο που αυτό συνέβη.

Με τη βοήθεια και του πίνακα συμβόλων, με το σημασιολογικό αναλυτή ελέγχεται:

* τύπος των τελούμενων σε αριθμητικές και λογικές πράξεις
* διπλός ορισμός ονόματος στην ίδια εμβέλεια (ορισμός μεταβλητής με όνομα που
  ήδη υπάρχει ή ορισμός συνάρτησης όταν ήδη έχει δοθεί ο ορισμός της ή ορισμός
  συνάρτησης με όνομα ίδιο με αυτό μεταβλητής ή το αντίστροφο)
* Κλήση συνάρτησης που δεν έχει δηλωθεί
* Κλήση συνάρτησης με λάθος αριθμό παραμέτρων
* Κλήση συνάρτησης με λάθος τύπο ορισμάτων
* Χρήση μεταβλητής που δεν έχει δηλωθεί
* Κλήση ``break`` ή ``continue`` εκτός loop
* Μη συμβατοί τύποι προορισμού και προέλευσης σε εντολές ανάθεσης
* Κλήση return εκτός συνάρτησης ή διαδικασίας ή παράλειψή του

5. Ενδιάμεσος κώδικας
----------------------

Ως ενδιάμεσος κώδικας επιλέχθηκαν οι τετράδες(quads). Η μετατροπή του αρχικού
κώδικα σε τετράδες γίνεται με τη χρήση συναρτήσεων που εφαρμόζονται στον Parser
αφού κάθε φορά γίνει πρώτα ο αντίστοιχος σημασιολογικός έλεγχος. Το τελικό
αποτέλεσμα παραγωγής τετράδων είναι μια λίστα με τετράδες, ενώ για διαδικασία
μετατροπής φτιάχτηκαν συγκεκριμένες δομές δεδομένων:

* ``expression_ret_type`` -> λίστα τετράδων και θέση της έκφρασης στο symbol table
* ``condition_ret_type`` -> λίστα τετράδων και true false lists
* ``statement_ret_type`` -> λιστα τετράδων και continue break lists
* ``inner_switch`` και ``switch`` ret types -> χρησιμοποιήθηκαν ώστε να μπορέσει να
  δομηθεί το switch ως διαδοχικά if else

Κατά τη διάρκεια της μετατροπής κώδικα σε τετράδες, οι προορισμοί των αλμάτων
είναι σχετικοί με τη θέση τους. Τα άλματα γίνονται σε int ref, το οποίο και
συμπεριλαμβάνεται στις εκάστοτε λίστες (true, false, continue, break). Όταν
υπάρχει συνένωση συνθήκηες ή τμημάτων κώδικα από τις συναρτήσεις παραγωγής
τετράδων, φροντίζουν να μεταβάλλουν τους δείκτες αλμάτων αντίστοιχα. Έτσι δεν
υπάρχει κάποιο τελικό backpatching, αλλά είναι μια διαδικασία που χτίζεται
σταδιακά και στο τέλος όλα τα σχετικά άλματα έχουν σωστές τιμές.


6. Βελτιστοποιήσεις
--------------------

Οι βελτιστοποιήσεις ξεκινάνε με constant propagation το οποίο περιλαμβάνει
διάδοση της τιμής των σταθερών και αποτίμηση όσων σταθερών εκφράσεων μπορούν
να αποτιμηθούν μετά απο διαδοχικές αντικαταστάσεις και αποτιμήσεις.

Στη συνέχεια, η λίστα με τις τετράδες διασπάται σε βασικά blocks (πίνακες) με
τρόπο τέτοιο ώστε να είναι πιο εύκολη η εφαρμογή βελτιστοποιήσεων ελέγχου ροής.
Η δομή έχει ως εξής: Υπάρχει ο εξωτερικός πίνακας τα κελιά του οποίου είναι το
καθένα μια συνάρτηση/υποπρόγραμμα/κυρίως πρόγραμμα (έστω block συνάρτησης). Σε
δεύτερο επίπεδο, το κάθε block συνάρτησης διασπάται σε πίνακες έτσι ώστε το
κελί/block του να έχει ως πρώτη τετράδα μια τετράδα που είναι προορισμός
κάποιου άλματος (είτε χωρίς, είτε υπό συνθήκη). Το κάθε τέτοιο βασικό block
περιέχει τις τετράδες του σε μορφή πίνακα.
Έχουμε επομένως έναν array of array of quad_t array.

Αφού χωριστεί η λίστα στα βασικά αυτά blocks ακολουθούν με τη σειρά οι παρακάτω
βελτιστοποιήσεις:

* immediate backward propagation -> Στην περίπτωση που έχουμε ανάθεση μιας
  τιμής σε προσωρινή μεταβλητή και αμέσως μετά ακολουθεί ανάθεσή της σε
  κανονική μεταβλητή, αντικαθιστούμε την προσωρινή μεταβλητή με την κανονική
  και αντικαθιστούμε την τετράδα ανάθεσης που ακολουθούσε με quad_dummy (θα 
  δούμε στη συνέχεια τι κάνουμε με αυτές)
  πχ, στην περίπτωση του ``i= i+1;``, από ``[(+, i, 1, $1), (:=, $1, -, i)]`` έχουμε
  ``[(+, i, 1, i), (quad_dummy)]``
* code deletion -> Αρχική διαγραφή απροσπέλαστου κώδικα. Με ένα γρήγορο πέρασμα
  στα blocks, διαγράφουμε(κάνουμε quad dummy) εύκολα όλες τις τετράδες ενός
  βασικού block που βρίσκονται κάτω από τετράδες άλματος χωρίς συνθήκη και
  τετράδες return.
* jump simplification -> Αντιστροφή συνθηκών ώστε να είναι πλέον περιττή και να
  διαγραφεί η τετράδα άλματος στην περίπτωση false. Η περίπτωση false πηγαίνει
  εκεί που πήγαινε το άλμα που ακολουθούσε τη συνθήκη και στην περίπτωση true
  συνεχίζει κάτω στην εκτέλεση κώδικα. Αυτή η βελτιστοποίηση είχε ως αποτέλεσμα
  τη δημιουργία μεγάλων(μακρινών) υπο συνθήκη αλμάτων, κάτι που, όπως φάνηκε
  στη συνέχεια, δεν μπορούσε να υλοποιηθεί από πλευράς assembly. Για αυτό το 
  λόγο η συγκεκριμένη βελτιστοποίηση, αν και υλοποιημένη,είναι απενεργοποιημένη
  προς το παρόν.
* dummy elimination -> Σε αυτό το βήμα διαγράφουμε όλες τις τετράδες dummy που
  έχουμε δημιουργήσει στα προηγούμενα βήματα
* convert to flow graph -> Μετατρέπουμε το κάθε block συνάρτησης σε γράφο
  σύμφωνα με τη ροή του προγράμματος, ώστε να μπορέσουν να ακολουθήσουν
  βελτιστοποιήσεις που βασίζονται στη ροή ελέγχου και ροή δεδομένων.
* unreachable code elimination -> με dfs στους γράφους που δημιουργήθηκαν
  διαγράφονται όλα τα απροσπέλαστα blocks. Πλέον διαγράφουμε και βασικά blocks
  ολόκληρα. Σε αντίθεση με την προηγούμενη διαγραφή κώδικα που ήταν σε επίπεδο
  βασικού block, αυτή λειτουργεί με βάση τα flow graphs που δημιουργήθηκαν σε 
  επίπεδο function block.
* copy propagation -> διάδοση αντιγράφων σε μεταβλητές με βάση τη χρήση τους
  και τη ροή δεδομένων.
* back to blocks -> μετατροπή από flow graphs πάλι σε blocks
* dummy elimination -> ξανά διαγραφή των dummies
* back to quad_list -> συνένωση των πινάκων σε ενιαίο πίνακα και αποτίμηση των
  αλμάτων σε απόλυτες τιμές.

7. Τελικός κώδικας
-------------------

Τελευταίο στάδιο του μεταγλωτιστή είναι η παραγωγή του τελικού κώδικα. Στο
στάδιο αυτό ο ενδιάμεσος κώδικας μετατρέπεται σε κώδικα assembly 8086 σύμφωνα με
το πρότυπο της Microsoft για συμβολομετάφραση με το συμβολομεταφραστή ``MASM``.

Το σχέδιο παραγωγής τελικού κώδικα είναι αυτό που προτείνεται στο βιβλίο του
μαθήματος, με βάση τη στοίβα. Επομένως, δεν υπάρχουν βελτιστοποιήσεις σχετικά με
τη δέσμευση καταχωρητών. Δεδομένου ότι δεδομένα τύπου int έχουν μήκος 2 byte,
ενώ τύπου char ή bool 1 byte γίνεται και ανάλογη ανάθεση σε καταχωρητές 1 ή 2
byte για τις πράξεις.

Επιπλέον, προστέθηκαν κάποιες βασικές συναρτήσεις βιβλιοθήκης στις δεδομένες για
να αντιστοιχούν 1 προς 1 με τις συναρτήσεις βιβλιοθήκης της PaZcal.

Για να ξεκινήσει η εκτέλεση δημιουργείται ένα υποτυπώδες εγγράγημα
δραστηριοποίησης το οποίο περιέχει και τις global μεταβλητές αν υπάρχουν και στη
συνέχεια γίνεται jump στο κατάλληλο σημείο του κώδικα για να ξεκινήσει η
εκτέλεση.

Επίσης, σχετικά με τις αλφαριθμητικές σταθερές που συναντώνται στο πρόγραμμα,
τοποθετούνται σε σταθερές θέσεις μνήνης στο τέλος του προγράμματος
χρησιμοποιώντας τη δυνατότητα που προσφέρει η assembly 8086 μέσω της εντολής
``db``.

Η μόνη βελτιστοποίηση τελικού κώδικα που πραγματοποιήθηκε ήταν στην περίπτωση
συνεχόμενων αναθέσεων στον ίδιο καταχωρητή, να διατηρείται μόνο η τελευταία
ανάθεση.
